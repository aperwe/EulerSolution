using QBits.Intuition.Mathematics;
using QBits.Intuition.Mathematics.Fibonacci;
using QBits.Intuition.Mathematics.Primes;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

namespace EulerProblems.Problems.Problems20to29
{
    /// <summary/>
    [ProblemSolver("Distinct powers", displayName = "Problem 29", problemDefinition =
@"Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

   2^2=4, 2^3=8, 2^4=16, 2^5=32
   3^2=9, 3^3=27, 3^4=81, 3^5=243
   4^2=16, 4^3=64, 4^4=256, 4^5=1024
   5^2=25, 5^3=125, 5^4=625, 5^5=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

   4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?"
        )]
    public class EulerProblem29 : AbstractEulerProblem
    {
        protected override void Solve(out string answer)
        {
            List<Pair> combinations = new List<Pair>();
            foreach (int a in Enumerable.Range(2, 100 - 1))
            {
                foreach (int b in Enumerable.Range(2, 100 - 1))
                {
                    Pair pair = new Pair(a, b);
                    combinations.Add(pair);
                }
            }
            combinations.ForEach(pair => pair.CalcPower());
            var powers = from pair in combinations
                         select pair.power;
            var distinctSorted = powers.AsParallel().Distinct().OrderBy(p => p);
            answer = string.Format("There are {0} distinct terms.", distinctSorted.Count());
        }
        class Pair
        {
            private BigInteger a;
            private BigInteger b;
            BigInteger aToB;
            internal BigInteger power => aToB;

            public Pair(int a, int b)
            {
                this.a = a;
                this.b = b;
            }

            internal void CalcPower()
            {
                aToB = a.Power(b);
            }
            public override string ToString()
            {
                return string.Format("{0}^{1} = {2}", a, b, power);
            }
        }
    }

}
