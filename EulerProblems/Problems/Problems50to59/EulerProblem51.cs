using QBits.Intuition.Collections;
using QBits.Intuition.Mathematics;
using QBits.Intuition.Mathematics.Primes;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.Design;
using System.Data.Odbc;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace EulerProblems.Problems.Problems50to59
{
    /// <summary/>
    [ProblemSolver("<Under construction>", "Problem 51 [TODO]",
@"By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family:
56003, 56113, 56333, 56443, 56663, 56773, and 56993.
Consequently 56003, being the first member of this family, is the smallest prime with this property.

Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.>")]
    public class EulerProblem51 : AbstractEulerProblem
    {
        PrimeSolver primeSolver = new();
        protected override void Solve(out string answer)
        {
            int result1 = VerifyStep1();
            answer = $"Step 1 complete. Result: {result1}. Expected: 6.{Environment.NewLine}";
            UpdateProgress(answer);
            var result2 = VerifyStep2("56**3");
            //Create string representation of result2, comma-separated
            var result2String = string.Join(", ", result2);
            answer += $"Step 2 complete. Result: {result2.Count()}; {result2String}. Expected: 7. Smallest: {result2.First()}.{Environment.NewLine}";
            UpdateProgress(answer);
            var result3 = VerifyStep3(8);
            answer += $"Step 3 complete. Result: {result3};";
        }

        /// <summary>
        /// By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.
        /// </summary>
        /// <exception cref="NotImplementedException"></exception>
        private int VerifyStep1()
        {
            // Step 1: Identify all 2-digit numbers ending with 3
            var numLength = 2; // 2-digit number
            var fixedDigit = 3; // ends with 3
            var primesFound = new List<long>();
            for (int digit = 1; digit <= 9; digit++) // first digit cannot be 0
            {
                var candidate = digit * 10 + fixedDigit;
                if (primeSolver.IsPrime(candidate))
                {
                    primesFound.Add(candidate);
                }
            }
            return primesFound.Count;
        }
        /// <summary>
        /// This function will take a prime format like "56**3" and verify how many primes can be generated by replacing the asterisks with the same digit.
        /// The first segment of the number is fixed as "56", the last digit is fixed as "3", and the two asterisks can be replaced with digits from 0 to 9.
        /// In this example, the asterisks have to be adjacent.
        /// In this example we expect a representation of a 5-digit number. First 2 will be fixed, and digits 3rd and 4th are flexible. Last digit is also fixed.
        /// The point is to iterate through all possible digit replacements for the asterisks and count how many of the resulting numbers are prime.
        /// The expected output is the count of prime numbers generated by this replacement.
        /// </summary>
        /// <param name="primeFormat">This is a preformatted string-version of a 5-digit number pattern to be tested for prime occurences.</param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        private IEnumerable<long> VerifyStep2(string primeFormat)
        {
            //If the format is not composed of digits or asterisks, throw an error
            if (!primeFormat.All(c => char.IsDigit(c) || c == '*'))
            {
                throw new ArgumentException("Invalid prime format. Must contain only digits and asterisks.");
            }
            var assumedLength = 5; //Assuming we are dealing with 5-digit numbers
            //Ensure the format is valid
            if (primeFormat.Length != assumedLength || primeFormat.Count(c => c == '*') != 2)
            {
                throw new ArgumentException("Invalid prime format. Must be a 5-character string with exactly two asterisks.");
            }
            var minNumber = (long)Math.Pow(10, assumedLength - 1);
            var maxNumber = (long)Math.Pow(10, assumedLength) - 1;
            //Find positions of the first asterisk in the string of digits and asterisks
            int firstAsteriskIndex = primeFormat.IndexOf('*');
            int secondAsteriskIndex = primeFormat.IndexOf('*', firstAsteriskIndex + 1);
            //Get the number after the last asterisk
            var suffixString = primeFormat.Substring(secondAsteriskIndex + 1);
            var suffixLong = long.Parse(suffixString);


            //Get the number before the first asterisk
            var prefix = primeFormat.Substring(0, firstAsteriskIndex); //This is "56" in the example
            var prefixLong = long.Parse(prefix); //Convert prefix to long
            long prefixMultiplier = (long)Math.Pow(10, assumedLength - firstAsteriskIndex); //Calculate the multiplier to shift the prefix to its correct position
            //Convert prefix to long and multiply by appropriate power of 10 to shift left
            long startOfTestRange = prefixLong * prefixMultiplier + suffixLong; //This gives us 56003 in the example
            if (startOfTestRange != 56003)
                throw new Exception("Unexpected starting position calculation.");

            //This is our starting position.
            //Now get the max number, assuming both asterisks are replaced with 9
            long maxAsteriskValue = 99 * (long)Math.Pow(10, assumedLength - secondAsteriskIndex - 1);
            long endOfTestRange = startOfTestRange + maxAsteriskValue + 1;
            //Create a concurrent collection of numbers to test for primality between start and end of test range
            var rangeToTest = Enumerable64.Range(startOfTestRange, maxAsteriskValue + 1).AsParallel();
            //Create a concurrent bag to hold found primes
            var resultCollection = new ConcurrentBag<long>();
            //Now, let's test the whole range, and if digits where asterixes are, are the same, then add them to resultCollection

            foreach (var item in rangeToTest)
            {
                if (primeSolver.IsNotPrime(item)) continue;

                //Test if digits in positions marked by asterixes are the same, because we count only such items
                var x = item.ToString();
                //Select only digits where asterixes were
                // Check that characters at the asterisk positions are equal
                if (x[firstAsteriskIndex] != x[secondAsteriskIndex]) continue;

                var currentSuffix = x.Substring(secondAsteriskIndex + 1);
                if (currentSuffix != suffixString) continue;

                //If we reach here, it means the number is prime and has the same digit in asterisk positions
                resultCollection.Add(item);

            }

            return resultCollection.OrderBy(x => x);
        }

        /// <summary>
        /// Tests the final step: Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.
        /// </summary>
        /// <param name="numLength">Is the number length (in digits)</param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        private long VerifyStep3(int numLength)
        {
            if (numLength != 8)
                throw new ArgumentException("This function currently only supports searching for 8-prime families.");
            //We will iterate through all primes with the given number of digits
            var minNumber = (long)Math.Pow(10, numLength - 1);
            var maxNumber = (long)Math.Pow(10, numLength) - 1;
            var rangeSize = maxNumber - minNumber + 1;
            var rangeToTest = Enumerable64.Range(minNumber, rangeSize);

            //Divide the range to test into 8 bags to test parallel on different CPUs
            var resultCollection = new ConcurrentBag<long>();
            var digits = "0123456789".ToCharArray();
            //Collections: for each digit we should create a separate bag collecting in parallel (using parallel-CPUs power) numbers that would be having the required octa-prime property
            ///First, create an array of collections for each digit
            ///TODO: How to create an array that for each digit in digits var it holds reference to a list of primes?
            //Create a map from a digit to a list
            long skippedPrimes = 0;


            //TODO: Implement the actual logic to find the smallest prime which is part of an eight prime value family by replacing digits.
            //      This route should be more efficient (by digit vs going by the whole range) -> more efficent to parallelize.
            Parallel.ForEach(digits, digit =>
            {

            });

            var patternedPrimesBag = new ConcurrentBag<PatternedPrimeRepresentation>();

            Parallel.ForEach(rangeToTest, item =>
            {
                lock (primeSolver)
                    if (primeSolver.IsNotPrime(item)) return;
                //Here we only collect primes for further processing

                var stringRep = item.ToString().ToArray();
                //We don't test more than 3-digit replacements, because all 3- or more patterns will be contained within 3-digit patterns
                //So we test only 3-digit replacement patterns
                //Identify triples of digits in stringRep
                Parallel.ForEach(digits, digit =>
                {
                    var sameDigitCount = stringRep.Count(c => c == digit);

                    if (sameDigitCount < 3)
                    {
                        lock (this) skippedPrimes++;
                        //Parallel loop ends here.
                    }
                    else
                    //Here we scan only those that have a pattern of 3 (minimum) or more
                    {
                        var testPattern = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                        var testPatternString = new string(testPattern);

                        PatternedPrimeRepresentation representation = new PatternedPrimeRepresentation { StarPattern = testPatternString, SameDigitCount = sameDigitCount, PrimeNumber = item, RepeatedDigit = digit };
                        patternedPrimesBag.Add(representation);

                        if (patternedPrimesBag.Count % 10000 == 0)
                        {
                            lock (this)
                                UpdateProgress($"Collected {patternedPrimesBag.Count} primes so far... Current item: {item}. Skipped: {skippedPrimes}. Range: {minNumber} - {maxNumber}");
                        }
                    }
                });
            });
            //Now we have all primes that have at least 3 occurrences of any digit in the range
            //Next step: for each digit, create patterns and check how many primes fit each pattern
            UpdateProgress($"Calculated all primes between {minNumber} and {maxNumber}. Collected {patternedPrimesBag.Count}.");
            var digitGroups = patternedPrimesBag.GroupBy(nr => nr.RepeatedDigit);
            foreach (var group in digitGroups)
            {
                var repeatedDigit = group.Key;
                var patternsForDigit = group.GroupBy(nr => nr.StarPattern);
                foreach (var patternGroup in patternsForDigit)
                {
                    var pattern = patternGroup.Key;
                    var itemsInPattern = patternGroup.Select(nr => nr.PrimeNumber).ToList();
                    if (itemsInPattern.Count !=8)
                    {
                        UpdateProgress($"Found pattern {pattern} for digit {repeatedDigit} with {itemsInPattern.Count} items: {string.Join(", ", itemsInPattern)}");
                    } else
                    if (itemsInPattern.Count >= 8)
                    {
                        UpdateProgress($"Found pattern {pattern} for digit {repeatedDigit} with {itemsInPattern.Count} items: {string.Join(", ", itemsInPattern)}");
                        return itemsInPattern.Min();
                    }
                }
            }
            return -1;
        }
        private long VerifyStep3BruteForce(int numLength)
        {
            if (numLength != 8)
                throw new ArgumentException("This function currently only supports searching for 8-prime families.");
            //We will iterate through all primes with the given number of digits
            var minNumber = (long)Math.Pow(10, numLength - 1);
            var maxNumber = (long)Math.Pow(10, numLength) - 1;
            var rangeSize = maxNumber - minNumber + 1;
            var primesInRange = new ConcurrentBag<long>();
            var rangeToTest = Enumerable64.Range(minNumber, rangeSize);

            //Divide the range to test into 8 bags to test parallel on different CPUs
            var resultCollection = new ConcurrentBag<long>();
            var digits = "0123456789".ToCharArray();
            //Collections: for each digit we should create a separate bag collecting in parallel (using parallel-CPUs power) numbers that would be having the required octa-prime property
            ///First, create an array of collections for each digit
            ///TODO: How to create an array that for each digit in digits var it holds reference to a list of primes?
            //Create a map from a digit to a list
            long skipped = 0;


            //TODO: Implement the actual logic to find the smallest prime which is part of an eight prime value family by replacing digits.
            //      This route should be more efficient (by digit vs going by the whole range) -> more efficent to parallelize.
            Parallel.ForEach(digits, digit =>
            {

            });


            Parallel.ForEach(rangeToTest, item =>
            {
                lock (primeSolver)
                    if (primeSolver.IsNotPrime(item)) return;
                var stringRep = item.ToString().ToArray();
                //We don't test more than 3-digit replacements, because all 3- or more patterns will be contained within 2-digit patterns
                //So we test only 2-digit replacement patterns
                //Identify pairs of digits in stringRep
                foreach (var digit in digits)
                {
                    var count = stringRep.Count(c => c == digit);
                    switch (count)
                    {
                        case 0:
                        case 1:
                            break; //No point in testing single or zero occurrences

                        case 2:
                            //We have exactly 2 occurrences of the digit
                            var testPattern = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                            var testPatternString = new string(testPattern);
                            break;

                        case 3:
                            //We have exactly 3 occurrences of the digit
                            //Create a test pattern with 3 asterisks
                            var testPattern3 = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                            var testPatternString3 = new string(testPattern3);
                            break;
                        case 4:
                            //We have exactly 4 occurrences of the digit
                            //Create a test pattern with 4 asterisks
                            var testPattern4 = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                            var testPatternString4 = new string(testPattern4);
                            break;
                        case 5:
                            //We have exactly 5 occurrences of the digit
                            //Create a test pattern with 5 asterisks
                            var testPattern5 = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                            var testPatternString5 = new string(testPattern5);
                            break;
                        case 6:
                            //We have exactly 6 occurrences of the digit
                            //Create a test pattern with 6 asterisks
                            var testPattern6 = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                            var testPatternString6 = new string(testPattern6);
                            break;
                        case 7:
                            //We have exactly 7 occurrences of the digit
                            //Create a test pattern with 7 asterisks
                            var testPattern7 = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                            var testPatternString7 = new string(testPattern7);
                            break;
                        case 8:
                            //We have exactly 8 occurrences of the digit
                            //Create a test pattern with 8 asterisks
                            var testPattern8 = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                            var testPatternString8 = new string(testPattern8);
                            break;
                        default:
                            //We have exactly 9 or more occurrences of the digit (quite impossible in a number of limited length)
                            //Create a test pattern with 8 asterisks
                            var testPattern9 = stringRep.Select(c => c == digit ? '*' : c).ToArray();
                            var testPatternString9 = new string(testPattern9);
                            break;
                    }
                    if (count < 2)
                    {
                        lock (this) skipped++;
                        continue; //We need at least 2 occurrences to form a family
                    }

                    primesInRange.Add(item);
                    if (primesInRange.Count % 100000 == 0)
                    {
                        lock (this)
                            UpdateProgress($"Collected {primesInRange.Count} primes so far... Current item: {item}. Skipped: {skipped}. Range: {minNumber} - {maxNumber}");
                    }
                }
            });
            //Now we have all primes in the range
            return -1;
        }

    }

    internal struct PatternedPrimeRepresentation
    {
        /// <summary>
        /// Pattern representation of the number, with asterisks in place of replaced digit, e.g. "56**3*9"
        /// </summary>
        public string StarPattern { get; set; }
        /// <summary>
        /// Number of occurrences of the replaced digit in the number, e.g. 3 or more.
        /// </summary>
        public int SameDigitCount { get; set; }
        /// <summary>
        /// The actual prime number represented, e.g. 5600309
        /// </summary>
        public long PrimeNumber { get; set; }
        /// <summary>
        /// The digit that is replaced in the pattern, e.g. '0'
        /// </summary>
        public char RepeatedDigit { get; set; }
    }
}