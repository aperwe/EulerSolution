using QBits.Intuition.Collections;
using QBits.Intuition.Mathematics;
using QBits.Intuition.Mathematics.Primes;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.Design;
using System.Data.Odbc;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace EulerProblems.Problems.Problems50to59
{
    /// <summary/>
    [ProblemSolver("<Under construction>", "Problem 51 [TODO]",
@"By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family:
56003, 56113, 56333, 56443, 56663, 56773, and 56993.
Consequently 56003, being the first member of this family, is the smallest prime with this property.

Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.>")]
    public class EulerProblem51 : AbstractEulerProblem
    {
        PrimeSolver primeSolver = new();
        protected override void Solve(out string answer)
        {
            int result1 = VerifyStep1();
            answer = $"Step 1 complete. Result: {result1}. Expected: 6";
            UpdateProgress(answer);
            var result2 = VerifyStep2("56**3");
            //Create string representation of result2, comma-separated
            var result2String = string.Join(", ", result2);
            answer += $"Step 2 complete. Result: {result2.Count()}; {result2String}. Expected: 7. Smallest: {result2.First()}";
            UpdateProgress(answer);
            var result3 = VerifyStep3(8);
            answer += $"Step 2 complete. Result: {result3};";
        }

        /// <summary>
        /// By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.
        /// </summary>
        /// <exception cref="NotImplementedException"></exception>
        private int VerifyStep1()
        {
            // Step 1: Identify all 2-digit numbers ending with 3
            var numLength = 2; // 2-digit number
            var fixedDigit = 3; // ends with 3
            var primesFound = new List<long>();
            for (int digit = 1; digit <= 9; digit++) // first digit cannot be 0
            {
                var candidate = digit * 10 + fixedDigit;
                if (primeSolver.IsPrime(candidate))
                {
                    primesFound.Add(candidate);
                }
            }
            return primesFound.Count;
        }
        /// <summary>
        /// This function will take a prime format like "56**3" and verify how many primes can be generated by replacing the asterisks with the same digit.
        /// The first segment of the number is fixed as "56", the last digit is fixed as "3", and the two asterisks can be replaced with digits from 0 to 9.
        /// In this example, the asterisks have to be adjacent.
        /// In this example we expect a representation of a 5-digit number. First 2 will be fixed, and digits 3rd and 4th are flexible. Last digit is also fixed.
        /// The point is to iterate through all possible digit replacements for the asterisks and count how many of the resulting numbers are prime.
        /// The expected output is the count of prime numbers generated by this replacement.
        /// </summary>
        /// <param name="primeFormat">This is a preformatted string-version of a 5-digit number pattern to be tested for prime occurences.</param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        private IEnumerable<long> VerifyStep2(string primeFormat)
        {
            //If the format is not composed of digits or asterisks, throw an error
            if (!primeFormat.All(c => char.IsDigit(c) || c == '*'))
            {
                throw new ArgumentException("Invalid prime format. Must contain only digits and asterisks.");
            }
            var assumedLength = 5; //Assuming we are dealing with 5-digit numbers
            //Ensure the format is valid
            if (primeFormat.Length != assumedLength || primeFormat.Count(c => c == '*') != 2)
            {
                throw new ArgumentException("Invalid prime format. Must be a 5-character string with exactly two asterisks.");
            }
            var minNumber = (long)Math.Pow(10, assumedLength - 1);
            var maxNumber = (long)Math.Pow(10, assumedLength) - 1;
            //Find positions of the first asterisk in the string of digits and asterisks
            int firstAsteriskIndex = primeFormat.IndexOf('*');
            int secondAsteriskIndex = primeFormat.IndexOf('*', firstAsteriskIndex + 1);
            //Get the number after the last asterisk
            var suffixString = primeFormat.Substring(secondAsteriskIndex + 1);
            var suffixLong = long.Parse(suffixString);


            //Get the number before the first asterisk
            var prefix = primeFormat.Substring(0, firstAsteriskIndex); //This is "56" in the example
            var prefixLong = long.Parse(prefix); //Convert prefix to long
            long prefixMultiplier = (long)Math.Pow(10, assumedLength - firstAsteriskIndex); //Calculate the multiplier to shift the prefix to its correct position
            //Convert prefix to long and multiply by appropriate power of 10 to shift left
            long startOfTestRange = prefixLong * prefixMultiplier + suffixLong; //This gives us 56003 in the example
            if (startOfTestRange != 56003)
                throw new Exception("Unexpected starting position calculation.");

            //This is our starting position.
            //Now get the max number, assuming both asterisks are replaced with 9
            long maxAsteriskValue = 99 * (long)Math.Pow(10, assumedLength - secondAsteriskIndex - 1);
            long endOfTestRange = startOfTestRange + maxAsteriskValue + 1;
            //Create a concurrent collection of numbers to test for primality between start and end of test range
            var rangeToTest = Enumerable64.Range(startOfTestRange, maxAsteriskValue + 1).AsParallel();
            //Create a concurrent bag to hold found primes
            var resultCollection = new ConcurrentBag<long>();
            //Now, let's test the whole range, and if digits where asterixes are, are the same, then add them to resultCollection

            foreach (var item in rangeToTest)
            {
                if (primeSolver.IsNotPrime(item)) continue;

                //Test if digits in positions marked by asterixes are the same, because we count only such items
                var x = item.ToString();
                //Select only digits where asterixes were
                // Check that characters at the asterisk positions are equal
                if (x[firstAsteriskIndex] != x[secondAsteriskIndex]) continue;

                var currentSuffix = x.Substring(secondAsteriskIndex + 1);
                if (currentSuffix != suffixString) continue;

                //If we reach here, it means the number is prime and has the same digit in asterisk positions
                resultCollection.Add(item);

            }

            return resultCollection.OrderBy(x => x);
        }

        /// <summary>
        /// Tests the final step: Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.
        /// </summary>
        /// <param name="numLength">Is the number length (in digits)</param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        private long VerifyStep3(int numLength)
        {
            if (numLength != 8)
                throw new ArgumentException("This function currently only supports searching for 8-prime families.");
            //We will iterate through all primes with the given number of digits
            var minNumber = (long)Math.Pow(10, numLength - 1);
            var maxNumber = (long)Math.Pow(10, numLength) - 1;
            var primesInRange = new ConcurrentBag<long>();
            var rangeToTest = Enumerable64.Range(minNumber, maxNumber - minNumber + 1);

            //Divide the range to test into 8 bags to test parallel on different CPUs
            var resultCollection = new ConcurrentBag<long>();
            var digits = "0123456789".ToCharArray();
            long skipped = 0;


            //TODO: Implement the actual logic to find the smallest prime which is part of an eight prime value family by replacing digits. This route should be more efficient (by digit vs going by the whole range) -> more efficent to parallelize.
            Parallel.ForEach(digits, digit =>
            {
            });


            Parallel.ForEach(rangeToTest, item =>
            {
                lock (primeSolver)
                    if (primeSolver.IsNotPrime(item)) return;
                var stringRep = item.ToString().ToArray();
                //We don't test more than 3-digit replacements, because all 3- or more patterns will be contained within 2-digit patterns
                //So we test only 2-digit replacement patterns
                //Identify pairs of digits in stringRep
                foreach (var digit in digits)
                {
                    var count = stringRep.Count(c => c == digit);
                    if (count < 2)
                    {
                        lock (this) skipped++;
                        continue; //We need at least 2 occurrences to form a family
                    }

                    primesInRange.Add(item);
                    if (primesInRange.Count % 100000 == 0)
                    {
                        lock (this)
                            UpdateProgress($"Collected {primesInRange.Count} primes so far... Current item: {item}. Skipped: {skipped}.");
                    }
                }
            });
            //Now we have all primes in the range
            return -1;
        }

    }
}