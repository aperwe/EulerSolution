using QBits.Intuition.Mathematics;
using QBits.Intuition.Mathematics.Fibonacci;
using QBits.Intuition.Mathematics.Primes;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

namespace EulerProblems.Problems
{
    /// <summary>
    /// Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
    /// 22=4, 23=8, 24=16, 25=32
    /// 32=9, 33=27, 34=81, 35=243
    /// 42=16, 43=64, 44=256, 45=1024
    /// 52=25, 53=125, 54=625, 55=3125
    /// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
    /// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
    /// How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
    /// </summary>
    [ProblemSolverClass("Problem 29", DisplayName = "Problem 29")]
    public class EulerProblem29 : AbstractEulerProblem
    {
        protected override void Solve(out string answer)
        {
            List<Pair> combinations = new List<Pair>();
            foreach (int a in Enumerable.Range(2, 100 - 1))
            {
                foreach (int b in Enumerable.Range(2, 100 - 1))
                {
                    Pair pair = new Pair(a, b);
                    combinations.Add(pair);
                }
            }
            combinations.ForEach(pair => pair.CalcPower());
            var powers = from pair in combinations
                         select pair.power;
            var distinctSorted = powers.AsParallel().Distinct().OrderBy(p => p);
            answer = string.Format("There are {0} distinct terms.", distinctSorted.Count());
        }
        class Pair
        {
            private BigInteger a;
            private BigInteger b;
            BigInteger aToB;
            internal BigInteger power => aToB;

            public Pair(int a, int b)
            {
                this.a = a;
                this.b = b;
            }

            internal void CalcPower()
            {
                aToB = a.Power(b);
            }
            public override string ToString()
            {
                return string.Format("{0}^{1} = {2}", a, b, power);
            }
        }
    }

}
