using QBits.Intuition.Mathematics;
using QBits.Intuition.Mathematics.Fibonacci;
using QBits.Intuition.Mathematics.Primes;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace EulerProblems.Problems
{
    /// <summary>
    /// Euler discovered the remarkable quadratic formula:
    /// n2+n+41
    /// 
    /// It turns out that the formula will produce 40 primes for the consecutive integer values 0≤n≤39.
    /// However, when n = 40, 402+40+41 = 40(40+1)+41 is divisible by 41, and certainly when n = 41, 412+41+41 is clearly divisible by 41.
    /// 
    /// The incredible formula n2−79n+1601 was discovered, which produces 80 primes for the consecutive values 0≤n≤79. The product of the coefficients, −79 and 1601, is −126479.
    /// 
    /// Considering quadratics of the form:
    /// n2+an+b, where |a|<1000 and |b|≤1000
    /// where |n| is the modulus/absolute value of n
    /// 
    /// Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.
    /// </summary>
    [ProblemSolverClass("Problem 27", DisplayName = "Problem 27")]
    public class EulerProblem27 : AbstractEulerProblem
    {
        protected override void Solve(out string answer)
        {
            //Produce all combinations
            List<Pair> list = new List<Pair>();
            foreach (long a in Enumerable.Range(-999, 2 * 999 + 1))
            {
                foreach (long b in Enumerable.Range(-1000, 2 * 1000 + 1))
                {
                    list.Add(new Pair(a: a, b: b));
                }
            }

            //Find primes
            list.AsParallel().ForAll(pair => pair.FindPrimes());

            //Get the pair with longest count of primes produced
            var ordered = list.OrderByDescending(pair => pair.NumPrimes);
            var output = ordered.First();
            answer = $"List size {list.Count}. The product of coefficients a ({output.A}) and b ({output.B}) is {output.CoefProduct}. Number of primes this pair generated is: {output.NumPrimes}.";
        }
    }

    internal class Pair
    {
        internal long A { get; private set; }
        internal long B { get; private set; }
        internal int NumPrimes { get { return primes.Count; } }
        internal long CoefProduct { get { return A * B; } }
        List<long> primes;

        public Pair(long a, long b)
        {
            this.A = a;
            this.B = b;
            primes = new List<long>();
        }
        public override string ToString()
        {
            return string.Format("{{0}, {1}}", A, B);
        }

        /// <summary>
        /// Finds primes that can be generated by this pair.
        /// </summary>
        internal void FindPrimes()
        {
            bool stayInLoop = true;
            long n = 0; //Starting value for n
            PrimeSolver primeSolver = new PrimeSolver();

            while (stayInLoop)
            {
                long quadratic = Quadratic(a: A, b: B, n: n);
                bool isPrime = primeSolver.IsPrime(quadratic);
                if (isPrime)
                {
                    primes.Add(quadratic);
                    n++;
                    continue;
                }
                stayInLoop = false; // If current quadratic is not a prime, exit the loop.
            }
        }

        /// <summary>
        /// Calculates n2 + an + b
        /// </summary>
        private long Quadratic(long a, long b, long n)
        {
            long result = n * n + a * n + b;
            return result;
        }
    }
}
