using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace QBits.Intuition.Mathematics.Fibonacci
{
    /// <summary>
    /// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    /// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    /// </summary>
    public class FibonacciSequence
    {
        LinkedList<Int64> dynamicSequence = new LinkedList<Int64>();
        /// <summary>
        /// Constructor of this class.
        /// </summary>
        public FibonacciSequence()
        {
            //Axiomatic constant value.
            dynamicSequence.AddLast(1);
            dynamicSequence.AddLast(2);
            dynamicSequence.AddLast(3);
        }

        /// <summary>
        /// Returns a Fibonacci sequence value at specified position.
        /// </summary>
        /// <param name="at">1-based index.</param>
        /// <returns></returns>
        public Int64 Get(int at)
        {
            if (at < 0) throw new IndexOutOfRangeException();
            if (at < 4) return at;
            return GetAt(at);
        }

        private Int64 GetAt(int at)
        {
            if (dynamicSequence.Count < at) //Need to do some computation
            {
                CreateItemsUntilAt(at);
            }
            return dynamicSequence.ElementAt(at - 1);
        }

        private void CreateItemsUntilAt(int at)
        {
            if (at == 1)
            {
                if (dynamicSequence.Count < 1)
                {
                    dynamicSequence.AddLast(1); //Axiom
                }
                return;
            }
            if (at == 2)
            {
                if (dynamicSequence.Count < 2)
                {
                    dynamicSequence.AddLast(2); //Axiom
                }
                return;
            }
            if (dynamicSequence.Count < at-1)
            {
                CreateItemsUntilAt(at - 1);
            }

            if (dynamicSequence.Count == at - 1)
            {
                var item1 = Get(at - 2);
                var item2 = Get(at - 1);
                dynamicSequence.AddLast(item1 + item2);
            }
        }
    }

    /// <summary>
    /// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    /// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    /// </summary>
    public class FibonacciSequenceBig
    {
        LinkedList<BigInteger> dynamicSequence = new LinkedList<BigInteger>();
        /// <summary>
        /// Public constructor.
        /// </summary>
        public FibonacciSequenceBig()
        {
            //Axiomatic constant value.
            dynamicSequence.AddLast(1);
            dynamicSequence.AddLast(2);
            dynamicSequence.AddLast(3);
        }

        /// <summary>
        /// Returns a Fibonacci sequence value at specified position.
        /// </summary>
        /// <param name="at">1-based index.</param>
        /// <returns></returns>
        public BigInteger Get(int at)
        {
            if (at < 0) throw new IndexOutOfRangeException();
            if (at < 4) return at;
            return GetAt(at);
        }

        private BigInteger GetAt(int at)
        {
            BigInteger result = 0;
            if (dynamicSequence.Count < at) //Need to do some computation
            {
                CreateItemsUntilAt(at);
            }
            return dynamicSequence.ElementAt(at - 1);
        }

        private void CreateItemsUntilAt(int at)
        {
            if (at == 1)
            {
                if (dynamicSequence.Count < 1)
                {
                    dynamicSequence.AddLast(1); //Axiom
                }
                return;
            }
            if (at == 2)
            {
                if (dynamicSequence.Count < 2)
                {
                    dynamicSequence.AddLast(2); //Axiom
                }
                return;
            }
            if (dynamicSequence.Count < at - 1)
            {
                CreateItemsUntilAt(at - 1);
            }

            if (dynamicSequence.Count == at - 1)
            {
                var item1 = Get(at - 2);
                var item2 = Get(at - 1);
                dynamicSequence.AddLast(item1 + item2);
            }
        }
    }
}
